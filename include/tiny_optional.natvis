<?xml version="1.0" encoding="utf-8"?>

<!--Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

- - - - - -

Original repository: https://github.com/Sedeniono/tiny-optional-->


<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">
  <!--Visualizer when storing the IsEmpty-Flag in a separate bool. I.e. when tiny::optional behaves just like std::optional.-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::DecompositionForSeparateFlag&lt;*&gt;, tiny::impl::SeparateFlagManipulator&gt;">
    <DisplayString Condition="mStorage.isEmptyFlag">nullopt (optional is empty)</DisplayString>
    <DisplayString Condition="!mStorage.isEmptyFlag">Not empty. Value={{{mStorage.payload}}}</DisplayString>
    <Expand>
      <Item Condition="!mStorage.isEmptyFlag" Name="value (not empty)">mStorage.payload</Item>
      <Item Condition="mStorage.isEmptyFlag" Name="value (is empty)">std::nullopt</Item>
      <Item Name="is_compressed">(*this).is_compressed</Item>
    </Expand>
  </Type>

  
  <!--Helper view to reduce code duplication in case tiny::impl::InplaceStorage is used.
  It relies on that a natvis instrinsic IsEmpty() is defined.-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;*, *&gt;" IncludeView="TinyOptionalInplaceStorageView">
    <DisplayString Condition="IsEmpty()">nullopt (optional is empty)</DisplayString>
    <DisplayString Condition="!IsEmpty()">Not empty. Value={{{mStorage.storage}}}</DisplayString>
    <Expand>
      <Item Condition="IsEmpty()" Name="value (is empty)">std::nullopt</Item>
      <Item Condition="!IsEmpty()" Name="value (not empty)">mStorage.storage</Item>
      <Item Name="is_compressed">(*this).is_compressed</Item>
    </Expand>
  </Type>
  
  
  <!--tiny::optional<bool>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceStoredTypeDecomposition&lt;*&gt;, tiny::optional_flag_manipulator&lt;bool, void&gt;&gt;">
    <Intrinsic Name="IsEmpty" Expression="(*(unsigned char*)&amp;mStorage.storage) == 0xfe"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>

  <!--tiny::optional<SomeClass, &SomeClass::someBool>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceDecompositionViaMemPtr&lt;*, *&gt;, tiny::optional_flag_manipulator&lt;bool, void&gt;&gt;">
    <!--Note: $T2 is the offset of the member in the class.-->
    <Intrinsic Name="IsEmpty" Expression="*(((unsigned char*)&amp;mStorage.storage) + $T2) == 0xfe"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>
  
  
  <!--tiny::optional<double>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceStoredTypeDecomposition&lt;*&gt;, tiny::optional_flag_manipulator&lt;double, void&gt;&gt;">
    <Intrinsic Name="IsEmpty" Expression="(*(unsigned long long*)&amp;mStorage.storage) == 0x7ff8fedcba987654"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>

  <!--tiny::optional<SomeClass, &SomeClass::someDouble>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceDecompositionViaMemPtr&lt;*, *&gt;, tiny::optional_flag_manipulator&lt;double, void&gt;&gt;">
    <!--Note: $T2 is the offset of the member in the class.-->
    <Intrinsic Name="IsEmpty" Expression="*(unsigned long long*)(((unsigned char*)&amp;mStorage.storage) + $T2) == 0x7ff8fedcba987654"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>
  
  
  <!--tiny::optional<float>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceStoredTypeDecomposition&lt;*&gt;, tiny::optional_flag_manipulator&lt;float, void&gt;&gt;">
    <Intrinsic Name="IsEmpty" Expression="(*(unsigned int*)&amp;mStorage.storage) == 0x7fedcba9"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>
  
  <!--tiny::optional<SomeClass, &SomeClass::someFloat>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceDecompositionViaMemPtr&lt;*, *&gt;, tiny::optional_flag_manipulator&lt;float, void&gt;&gt;">
    <!--Note: $T2 is the offset of the member in the class.-->
    <Intrinsic Name="IsEmpty" Expression="*(unsigned int*)(((unsigned char*)&amp;mStorage.storage) + $T2) == 0x7fedcba9"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>
  
  
  <!--For types:
         - tiny::optional<T*>, 
         - tiny::optional<funcPointer> 
         - Types with custom specialized tiny::optional_flag_manipulator.
  This is quite tricky: I haven't found a way to specify a visualizer for all pointer types only. Also, there is the
  PRIORITY attribute which can be used to select another visualizer in case another one causes an error, but this is
  actually somewhat annoying since even if another one is ok Visual Studio write an error to the debug output (if the
  natvis error debug output is enabled in the options).
  So instead this visualizer accepts EVERY tiny::optional_flag_manipulator<T, void>. If T is bool, float or double, 
  the "overloads" above are used. If T is anything else, this here is used. The trick to check whether T is a pointer 
  or not is in the definition of the IsEmpty() intrinsic: We do *&mStorage.storage, which is invalid if storage is not 
  a pointer. Then, the condition "IsEmpty() || !IsEmpty()" is always true for a pointer and undefined for non-pointers.
  In case of undefined, the Optional="true" comes into play.
  Note: Using pure natvis, it is impossible to properly query the IsEmpty flag. Natvis does not allow to call functions,
  even constexpr ones. It is afraid of potential side effects. So for custom optional_flag_manipulator specializations,
  the best we can do is to show the raw storage.
  -->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceStoredTypeDecomposition&lt;*&gt;, tiny::optional_flag_manipulator&lt;*, void&gt;&gt;">
    <Intrinsic Name="IsEmpty" Optional="true" Expression="
               sizeof(&amp;*mStorage.storage) == 4
               ? ((unsigned int)(void*)mStorage.storage) == 0xffffffff - 8
               : ((unsigned long long)(void*)mStorage.storage) == 0xffff800000000000ull - 1
               "/>
    <!--Used for pointers-->
    <DisplayString Optional="true" Condition="IsEmpty() || !IsEmpty()">{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <!--Used for non-pointers (custom optional_flag_manipulator specializations)-->
    <DisplayString>(Preview for custom flag manipulators not supported in natvis)</DisplayString>
    <Expand>
      <ExpandedItem Optional="true" Condition="IsEmpty() || !IsEmpty()">this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
      <!--Also show the raw storage, which should help for custom optional_flag_manipulator specializations.-->
      <Item Name="Raw storage (compressed)">mStorage.storage</Item>
    </Expand>
  </Type>

  <!--For types:
         - tiny::optional<SomeClass, &SomeClass::somePtr>
         - tiny::optional<SomeClass, &SomeClass::someFuncPtr>
         - tiny::optional<SomeClass, &SomeClass::someMember>, where the type of someMember has a custom specialized tiny::optional_flag_manipulator.
  See the above visualizer for tiny::optional<T*> for an explanation.
  -->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceDecompositionViaMemPtr&lt;*, *&gt;, tiny::optional_flag_manipulator&lt;*, void&gt;&gt;">
    <!--Note: $T2 is the offset of the member in the class.-->
    <Intrinsic Name="IsEmpty" Optional="true" Expression="
               sizeof(&amp;**(FlagType*)(((unsigned char*)&amp;mStorage.storage) + $T2)) == 4
               ? ((unsigned int)(void*)*(FlagType*)(((unsigned char*)&amp;mStorage.storage) + $T2)) == 0xffffffff - 8
               : ((unsigned long long)(void*)*(FlagType*)(((unsigned char*)&amp;mStorage.storage) + $T2)) == 0xffff800000000000ull - 1
               "/>
    <!--Used for pointers-->
    <DisplayString Optional="true" Condition="IsEmpty() || !IsEmpty()">{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <!--Used for non-pointers (custom optional_flag_manipulator specializations)-->
    <DisplayString>(Preview for custom flag manipulators not supported in natvis)</DisplayString>
    <Expand>
      <ExpandedItem Optional="true" Condition="IsEmpty() || !IsEmpty()">this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
      <!--Also show the raw storage, which should help for custom optional_flag_manipulator specializations.-->
      <Item Name="Raw storage (compressed)">mStorage.storage</Item>
    </Expand>
  </Type>

  
  <!--tiny::optional<unsigned, 999>. 
  Used when a sentinel has been specified explicitly, i.e. when the 2nd template argument is a AssignmentFlagManipulator.
  We cannot explicitly write AssignmentFlagManipulator because then we wouldn't be able to access valueToIndicateEmpty here in natvis.-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceStoredTypeDecomposition&lt;*&gt;, *&gt;">
    <Intrinsic Name="IsEmpty" Expression="mStorage.storage == $T2::valueToIndicateEmpty"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>

  <!--tiny::optional<SomeClass, &SomeClass::someUnsigned, 42>-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;tiny::impl::InplaceDecompositionViaMemPtr&lt;*, *&gt;, *&gt;">
    <!--Note: $T2 is the offset of the member in the class.-->
    <Intrinsic Name="IsEmpty" Expression="*(FlagType*)(((unsigned char*)&amp;mStorage.storage) + $T2) == $T3::valueToIndicateEmpty"/>
    <DisplayString>{*this,view(TinyOptionalInplaceStorageView)}</DisplayString>
    <Expand>
      <ExpandedItem>this,view(TinyOptionalInplaceStorageView)</ExpandedItem>
    </Expand>
  </Type>
  
  
  <!--Fall back for any other optionals: Simply display the raw storage.-->
  <Type Name="tiny::impl::TinyOptionalImpl&lt;*, *&gt;" Priority="Low">
    <DisplayString>(Preview is not supported)</DisplayString>
    <Expand>
      <Item Name="Raw storage">mStorage.storage</Item>
      <Item Name="is_compressed">(*this).is_compressed</Item>
    </Expand>
  </Type>
</AutoVisualizer>
